//COMMON QUEUE
class MyQueue {
public:
    int tail, head;
    vector<int> queue;
    MyQueue(int K_MAX) {//max_length of queue
        head = 0;
        tail = -1;
        queue.assign(K_MAX, 0);
    }
    void push(int x) {
        tail = (tail+1)%3;
        queue[tail] = x;
    }
    int pop() {
        int t = head;
        head = (head+1)%3;
        return queue[t];
    }
    int peek() {
        return queue[head];
    }
    bool empty() {
        return tail == head-1;
    }
};


//HAND-MADE PRIORITY QUEUE WITH OPTIONAL DATA (VIA ".SECOND")
void heap_push(vector<pair<int, int>>& heap, pair<int, int> priority_goblin){
    int pos = (int) heap.size();
    heap.push_back(priority_goblin);
    while (pos > 0 && heap[pos].first < heap[(pos-1)/2].first){
        swap(heap[pos], heap[(pos-1)/2]);
        pos = (pos-1)/2;   
    }
}
void heap_erase(vector<pair<int, int>>& heap){
    int isz = (int) heap.size();
    heap[0] = heap[isz - 1];
    heap.pop_back(); isz--;
    int i = 0;
    while (1){
        int child1 = 2*i + 1;
        int child2 = 2*i + 2;
        if (child1 < isz && child2 < isz){
            if(heap [child1].first >= heap[child2] .first&& heap[child2].first < heap[i].first) {
                swap(heap[i], heap[child2]);
                i = child2;
            }
            else if (heap [child1].first <= heap[child2].first && heap[child1].first < heap[i].first){
                swap(heap[i], heap[child1]);
                i = child1;
            }
            else{
                break;
            }
        } 
        else if (child1 < isz && child2 >= isz){
            if(heap[child1].first < heap[i].first) {
                swap(heap[i], heap[child1]);
                i = child1;
            }
            else break;
        }
        else if (child2 < isz && child1 >= isz){
            if(heap[child2].first < heap[i].first) {
                swap(heap[i], heap[child2]);
                i = child2;
            }
            else break;
        }
        else break;
    }
}




//
